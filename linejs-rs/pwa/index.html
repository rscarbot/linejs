<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#06C755">
  <meta name="description" content="LINE Messaging Client powered by Rust + WebAssembly">
  <link rel="manifest" href="manifest.json">
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üí¨</text></svg>">
  <title>LINEJS WASM</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="header">
    <span style="font-size: 22px;">üí¨</span>
    <h1>LINEJS</h1>
    <span class="badge">WASM + Rust</span>
    <div class="status-dot" id="status-dot"></div>
    <button id="btn-logout" onclick="doLogout()"
      style="display:none; background:none; border:none; color:white; font-size:20px; cursor:pointer; margin-left:8px;"
      title="Logout">üö™</button>
  </div>

  <div class="container">
    <!-- Login Screen -->
    <div class="screen active" id="login-screen">
      <div class="login-logo">üîê</div>
      <div class="login-title">LINE Messenger</div>
      <div class="login-desc">
        End-to-end encrypted messaging powered by Rust and WebAssembly.
        Login with your LINE account via QR code.
      </div>

      <div class="device-selector"
        style="margin-bottom: 20px; display: flex; gap: 10px; align-items: center; justify-content: center;">
        <label for="device-mode" style="font-size: 14px; font-weight: 600;">Device Mode:</label>
        <select id="device-mode"
          style="padding: 8px; border-radius: 8px; border: 1px solid #ddd; background: #f5f5f5; font-size: 14px;">
          <option value="ipad" selected>iPad (Default)</option>
          <option value="desktop">PC (Windows)</option>
        </select>
      </div>

      <button class="btn btn-primary" id="btn-login" onclick="startLogin()">
        Login with QR Code
      </button>
    </div>

    <!-- QR Code Screen -->
    <div class="screen" id="qr-screen">
      <div class="qr-label">Scan QR Code</div>
      <div class="qr-sublabel">Open LINE on your phone and scan this code</div>
      <div class="qr-container">
        <img id="qr-image" alt="QR Code" />
      </div>
      <div class="spinner" id="qr-spinner" style="display:none;"></div>
      <div class="qr-sublabel" id="qr-status">Waiting for scan...</div>
      <button class="btn btn-secondary" onclick="cancelLogin()" style="margin-top: 10px;">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
        Cancel
      </button>
    </div>

    <!-- PIN Screen -->
    <div class="screen" id="pin-screen">
      <div style="font-size: 40px;">üì±</div>
      <div class="qr-label">Enter PIN Code</div>
      <div class="qr-sublabel">Enter this code on your mobile device</div>
      <div class="pin-display" id="pin-display">------</div>
      <div class="spinner" id="pin-spinner"></div>
      <div class="qr-sublabel" id="pin-status">Waiting for verification...</div>
    </div>

    <!-- Chat Screen -->
    <div class="screen" id="chat-screen">
      <div class="messages-container" id="messages-container">
        <div class="message system">Waiting for messages...</div>
      </div>
    </div>
  </div>

  <div class="status-bar" id="status-bar">Initializing WASM runtime...</div>

  <button class="log-toggle" onclick="toggleLog()">Console</button>
  <div class="log-panel" id="log-panel"></div>

  <script type="module">
    import init, { LineClient } from './pkg/linejs_wasm.js';

    let client = null;
    let pollInterval = null;
    let loginGen = 0; // Generation counter to stop old polls

    // Expose functions to global scope for onclick handlers
    window.startLogin = startLogin;
    window.toggleLog = toggleLog;
    window.doLogout = doLogout;
    window.cancelLogin = cancelLogin;

    function doLogout() {
      localStorage.removeItem('linejs_credentials');
      setOnline(false);
      document.getElementById('btn-logout').style.display = 'none';
      document.getElementById('btn-login').disabled = false;
      document.getElementById('btn-login').textContent = 'Login with QR Code';
      document.getElementById('messages-container').innerHTML = '<div class="message system">Waiting for messages...</div>';
      showScreen('login-screen');
      setStatus('Logged out. Ready to login');
      log('Logged out, credentials cleared', 'success');
      // Re-create client to clear internal state
      if (client) {
        try { client.free(); } catch (e) { }
      }
      client = new LineClient();
      loginGen++;
    }

    function cancelLogin() {
      log('Login cancelled by user');
      showScreen('login-screen');
      document.getElementById('btn-login').disabled = false;
      document.getElementById('btn-login').textContent = 'Login with QR Code';
      setStatus('Login cancelled. Ready to login');
      // Re-create client to clear login state
      if (client) {
        try { client.free(); } catch (e) { }
      }
      client = new LineClient();
      loginGen++;
    }

    function log(msg, type = '') {
      const panel = document.getElementById('log-panel');
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + type;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      panel.appendChild(entry);
      panel.scrollTop = panel.scrollHeight;
      console.log(`[LINEJS] ${msg}`);
    }

    function toggleLog() {
      document.getElementById('log-panel').classList.toggle('open');
    }

    function showScreen(id) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(id).classList.add('active');
    }

    function setStatus(msg) {
      document.getElementById('status-bar').textContent = msg;
    }

    function setOnline(online) {
      const dot = document.getElementById('status-dot');
      dot.classList.toggle('online', online);
    }

    const CRED_KEY = 'linejs_credentials';

    // Initialize WASM and attempt auto-login from saved credentials
    async function initWasm() {
      try {
        await init();
        client = new LineClient();
        log('WASM runtime initialized', 'success');

        // Try auto-login from saved credentials
        const saved = localStorage.getItem(CRED_KEY);
        if (saved) {
          try {
            client.loginWithToken(saved);

            // Update UI dropdown to match saved device type
            try {
              const parsed = JSON.parse(saved);
              if (parsed.deviceType) {
                const select = document.getElementById('device-mode');
                if (parsed.deviceType === 'desktop') {
                  select.value = 'desktop';
                } else {
                  select.value = 'ipad';
                }
                log('Restored device mode: ' + parsed.deviceType);
              }
            } catch (e) {
              console.warn('Failed to parse saved device type', e);
            }

            log('Session restored from saved credentials', 'success');
            setStatus('Logged in - Listening for messages');
            setOnline(true);
            document.getElementById('btn-logout').style.display = '';
            showScreen('chat-screen');
            addSystemMessage('Session restored. Listening for messages...');
            startMessagePolling();
            return;
          } catch (e) {
            log('Auto-login failed (token may be expired): ' + e, 'error');
            localStorage.removeItem(CRED_KEY);
            // Fall through to show login screen
          }
        }

        setStatus('Ready to login');
      } catch (e) {
        setStatus('Failed to initialize WASM');
        log('WASM init error: ' + e, 'error');
      }
    }

    async function startLogin() {
      if (!client) return;

      const deviceMode = document.getElementById('device-mode').value;
      if (client.setDevice) {
        client.setDevice(deviceMode);
        log('Set device mode to: ' + deviceMode);
      } else {
        log('setDevice method not found on client', 'warn');
      }

      const btn = document.getElementById('btn-login');
      btn.disabled = true;
      btn.textContent = 'Connecting...';
      setStatus('Creating login session...');
      log('Starting QR login flow...');

      const currentGen = ++loginGen;

      try {
        const resultStr = await client.createQrLogin();
        // Check if cancelled during await
        if (currentGen !== loginGen) {
          log('Login flow cancelled during creation', 'warn');
          return;
        }

        const result = JSON.parse(resultStr);
        log('QR code generated', 'success');

        // Show QR screen
        showScreen('qr-screen');
        document.getElementById('qr-image').src = result.qrImageUrl;
        setStatus('Scan the QR code with LINE app');

        // Poll for QR verification
        pollQrVerification(currentGen);
      } catch (e) {
        log('Login error: ' + e, 'error');
        setStatus('Login failed: ' + e);
        btn.disabled = false;
        btn.textContent = 'Login with QR Code';
      }
    }

    async function pollQrVerification(gen) {
      if (gen !== loginGen) return; // Stop if new login started

      log('Waiting for QR scan...');
      document.getElementById('qr-status').textContent = 'Waiting for scan...';

      try {
        const verified = await client.checkQrCodeVerified();
        if (verified) {
          log('QR code scanned!', 'success');
          document.getElementById('qr-status').textContent = 'Scanned!';
          setStatus('QR code scanned, verifying...');
          await handlePostScan();
        } else {
          log('QR poll timeout, retrying...');
          // Retry
          if (gen === loginGen) {
            pollQrVerification(gen);
          }
        }
      } catch (e) {
        log('QR verification error: ' + e, 'error');
        setStatus('QR verification error');
      }
    }

    async function handlePostScan() {
      // Try certificate verification first
      try {
        const certOk = await client.verifyCertificate();
        if (certOk) {
          log('Certificate verified, skipping PIN', 'success');
          await completeLogin();
          return;
        }
      } catch (e) {
        log('Certificate check: ' + e);
      }

      // Need PIN code
      try {
        const pin = await client.createPinCode();
        log('PIN code: ' + pin, 'success');
        showScreen('pin-screen');
        document.getElementById('pin-display').textContent = pin;
        setStatus('Enter PIN on your mobile device');

        pollPinVerification();
      } catch (e) {
        log('PIN creation error: ' + e, 'error');
        setStatus('PIN creation failed');
      }
    }

    async function pollPinVerification() {
      log('Waiting for PIN verification...');
      try {
        const verified = await client.checkPinCodeVerified();
        if (verified) {
          log('PIN verified!', 'success');
          setStatus('PIN verified, logging in...');
          await completeLogin();
        } else {
          log('PIN poll timeout, retrying...');
          pollPinVerification();
        }
      } catch (e) {
        log('PIN verification error: ' + e, 'error');
        setStatus('PIN verification error');
      }
    }

    async function completeLogin() {
      try {
        const token = await client.qrCodeLogin();
        log('Login successful! Token: ' + token.substring(0, 20) + '...', 'success');

        // Save credentials to localStorage for next visit
        const creds = client.exportCredentials();
        if (creds) {
          localStorage.setItem(CRED_KEY, creds);
          log('Credentials saved to localStorage', 'success');
        }

        setStatus('Logged in - Listening for messages');
        setOnline(true);
        document.getElementById('btn-logout').style.display = '';

        showScreen('chat-screen');
        addSystemMessage('Connected! Listening for messages...');

        // Start message polling
        startMessagePolling();
      } catch (e) {
        log('Login completion error: ' + e, 'error');
        setStatus('Login failed: ' + e);
      }
    }

    function startMessagePolling() {
      let pollCount = 0;
      let backoff = 200;

      async function poll() {
        try {
          const resultStr = await client.pollMessages();
          const messages = JSON.parse(resultStr);

          // Reset backoff on success
          backoff = 200;

          for (const msg of messages) {
            addChatMessage(msg.text, msg.isSend, msg.from, msg.to);
            log(`Message: [From:${msg.from}] [To:${msg.to}] ${msg.text}`);
          }

          // Re-save credentials every 10 polls to persist newly discovered peer keys
          pollCount++;
          if (pollCount % 10 === 0) {
            const creds = client.exportCredentials();
            if (creds) {
              localStorage.setItem(CRED_KEY, creds);
            }
          }

          setOnline(true);
          setStatus('Logged in - Listening for messages');
        } catch (e) {
          const errStr = String(e);
          log('Poll error: ' + errStr, 'error');

          // Detect token expiry / auth errors ‚Üí clear credentials and revert to login
          if (errStr.includes('AUTHENTICATION_DIVESTED_BY_OTHER_DEVICE') ||
            errStr.includes('NOT_AUTHORIZED') ||
            errStr.includes('AUTHENTICATION_FAILED')) {
            log('Session expired, clearing credentials', 'error');
            localStorage.removeItem(CRED_KEY);
            setOnline(false);
            document.getElementById('btn-logout').style.display = 'none';
            document.getElementById('btn-login').disabled = false;
            document.getElementById('btn-login').textContent = 'Login with QR Code';
            showScreen('login-screen');
            setStatus('Session expired. Please login again');
            addSystemMessage('Session expired. Please login again.');
            return; // Stop polling
          }

          // Network / proxy errors ‚Üí keep credentials, back off and retry
          setOnline(false);
          setStatus('Offline - Retrying in ' + Math.round(backoff / 1000) + 's...');
          backoff = Math.min(backoff * 2, 30000); // Max 30s backoff
        }

        setTimeout(poll, backoff);
      }

      poll();
    }

    function isAtBottom(container) {
      return container.scrollHeight - container.scrollTop - container.clientHeight < 50;
    }

    function addSystemMessage(text) {
      const container = document.getElementById('messages-container');
      const div = document.createElement('div');
      div.className = 'message system';
      div.textContent = text;
      container.appendChild(div);
      // Always scroll to bottom for system messages (e.g. first login)
      container.scrollTop = container.scrollHeight;
    }

    function addChatMessage(text, isSend, from, to) {
      const container = document.getElementById('messages-container');
      // Check if user is at bottom BEFORE appending
      const shouldScroll = isAtBottom(container);

      const div = document.createElement('div');
      div.className = 'message ' + (isSend ? 'sent' : 'received');

      const textNode = document.createElement('div');
      textNode.textContent = text;
      div.appendChild(textNode);

      const meta = document.createElement('div');
      meta.className = 'meta';
      // Display full MIDs for debugging
      meta.textContent = (isSend ? 'You' : '') +
        ' [From: ' + from + ']' +
        (to ? ' [To: ' + to + ']' : '') +
        ' ¬∑ ' + new Date().toLocaleTimeString();
      div.appendChild(meta);

      container.appendChild(div);
      // Only auto-scroll if user was already at the bottom
      if (shouldScroll) {
        container.scrollTop = container.scrollHeight;
      }
    }

    // Install service worker for PWA
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then(() => {
        log('Service worker registered');
      }).catch(e => {
        log('SW registration failed: ' + e);
      });
    }

    // Boot
    initWasm();
  </script>
</body>

</html>