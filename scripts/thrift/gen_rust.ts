import thriftIdl from "./thrift-idl.js";

const TYPE_MAPPING: Record<string, string> = {
    BOOL: "bool",
    BYTE: "i8",
    I08: "i8",
    DOUBLE: "f64",
    I16: "i16",
    I32: "i32",
    I64: "i64",
    STRING: "String",
    UTF7: "String",
    UTF8: "String",
    UTF16: "String",
    BINARY: "Vec<u8>",
};

// Global sets to track definitions and usage
const definedTypes = new Set<string>();
const referencedTypes = new Set<string>();
const emittedTypes = new Set<string>();

function getRustType(obj: any): string {
    if (obj.type === "BaseType") {
        const base = obj.baseType.toUpperCase();
        if (base === "BINARY") return "Vec<u8>";
        return TYPE_MAPPING[base] || "String"; 
    } else if (obj.type === "Identifier") {
        referencedTypes.add(obj.name);
        return obj.name;
    } else if (obj.type === "List") {
        return `Vec<${getRustType(obj.valueType)}>`;
    } else if (obj.type === "Set") {
        // Map Set to Vec to avoid Hash/Eq issues
        return `Vec<${getRustType(obj.valueType)}>`;
    } else if (obj.type === "Map") {
        return `std::collections::HashMap<${getRustType(obj.keyType)}, ${getRustType(obj.valueType)}>`;
    }
    return "String";
}

function generateRust(input: string): string {
    const ast = thriftIdl.parse(input);
    let out = `// Generated by scripts/thrift/gen_rust.ts
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused_imports)]
#![allow(clippy::all)]

use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};
use serde_json::Value;
use std::collections::HashMap;

`;

    // First pass: collect definitions
    ast.definitions.forEach((def: any) => {
         if (def.type === "Enum" || def.type === "Struct" || def.type === "Exception") {
             definedTypes.add(def.id.name);
         }
    });

    // Second pass: Generate code
    ast.definitions.forEach((def: any) => {
        if (def.type === "Enum") {
            const name = def.id.name;
            if (emittedTypes.has(name)) return;
            emittedTypes.add(name);

            out += `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize_repr, Deserialize_repr)]\n`;
            out += `#[repr(i32)]\n`;
            out += `pub enum ${name} {\n`;
            def.definitions.forEach((d: any) => {
                const valName = d.id.name;
                const valValue = d.value.value;
                out += `    ${valName} = ${valValue},\n`;
            });
            out += `}\n\n`;

        } else if (def.type === "Struct" || def.type === "Exception") {
            const name = def.id.name;
            if (emittedTypes.has(name)) return;
            emittedTypes.add(name);
            
            out += `#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\n`;
            out += `pub struct ${name} {\n`;
            def.fields.forEach((f: any) => {
                const fName = f.name;
                let fType = getRustType(f.valueType);
                
                let safeName = fName;
                if (["type", "struct", "enum", "match", "box", "crate", "super", "self", "Self", "pub", "mod", "use", "fn", "let", "const", "static", "trait", "impl", "ref", "abstract", "async", "await", "become", "do", "final", "macro", "override", "priv", "typeof", "unsized", "virtual", "yield", "try", "union"].includes(fName)) {
                    safeName = `r#${fName}`;
                }

                out += `    #[serde(rename = "${fName}")]\n`;
                if (!fType.startsWith("Option")) {
                    out += `    pub ${safeName}: Option<${fType}>,\n`;
                } else {
                     out += `    pub ${safeName}: ${fType},\n`;
                }
            });
            out += `}\n\n`;
        }
    });

    // Third pass: Generate missing types
    referencedTypes.forEach(t => {
        if (!definedTypes.has(t)) {
             // Handle duplicate referencedTypes checks implicitly by Set
             // BUT definedTypes check covers if it was ever defined.
             out += `pub type ${t} = Value;\n`;
        }
    });

    return out;
}

const thriftContent = Deno.readTextFileSync("resources/line/line.thrift");
const rustCode = generateRust(thriftContent);
Deno.writeTextFileSync("linejs-rs/core/src/gen.rs", rustCode);
console.log("Generated linejs-rs/core/src/gen.rs");
